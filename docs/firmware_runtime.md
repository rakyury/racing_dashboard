# Черновой рантайм firmware

Этот пример иллюстрирует, как можно строить модульную прошивку для приборной панели:
- фильтрация входов и расчёт производных каналов (math channels);
- приоритезированная логика переключения экранов и алертов;
- управление яркостью от датчика освещённости с ручным override;
- TouchGFX-экраны с современным стилем à la Motec (RPM, давления/температуры, батарея, буст, положение заслонки, AFR текущий/целевой);
- внешнее видео (HDMI/CarPlay/Android Auto) с оверлеем;
- логгер событий для отладки.

## Ключевые компоненты
- `SignalBus` — общая шина значений, в которую пишут драйверы ввода и math-каналы.
- `MathEngine` — вычисляет производные каналы (скорость, уровень shift-light и т.д.).
- `AlertManager` — алерты с уровнями (info/warn/crit) и возможностью защёлкивания.
- `DisplayManager` — переключает экраны по условиям с приоритетами, рендерит оверлей.
- `BrightnessController` — переводит освещённость в уровень подсветки, поддерживает ручной режим.
- `ExternalInputManager` — абстракция над HDMI/CarPlay/Android Auto, оставляет оверлей поверх видеопотока.
- `DataLogger` — собирает события рантайма для быстрой диагностики.
- `HealthMonitor` — проверяет свежесть сигналов и поднимает алерты при пропадании сенсоров/шин.
- `Runtime` — фасад над всеми подсистемами, принимает `RuntimeProfile` (экраны, условия, math-каналы, правила здоровья)
  и `RuntimeInputs` (значения сенсоров + источник внешнего видео), после чего вызывает `step()` для обновления состояния.

## Расширения для железа
- Подключить реальные драйверы (CAN, ADC, GPIO, дисплей) и публиковать данные в `SignalBus`.
- Заменить `std::cout` на инфраструктуру трассировки/логгирования MCU.
- Привязать `BrightnessController` к ALS (I2C) и PWM-драйверу подсветки.
- Реализовать буферизацию логов в двоичном формате и их выгрузку по USB/Wi‑Fi.
- Добавить проверку доступности внешнего видео и состояния лицензий (MFi/AA).

## Быстрый старт
1. Откройте `src/device_runtime.cpp` и изучите `demo_runtime()` как сценарий.
2. Добавьте свои каналы или условия, используя примеры `register_condition` и `MathEngine::register_channel`.
3. Замените заглушки в `ExternalInputManager::process_frame` под ваш видеоканал и пайплайн оверлея.
4. Создайте `RuntimeProfile` с нужными маршрутами/экранами, передайте его в `Runtime`, а затем кормите `RuntimeInputs`
   (сенсоры, режим подсветки, источник видео) в цикле таймера MCU.

## TouchGFX: как собраны экраны
- В коде добавлен лёгкий «адаптер» `TouchGFXScreen`, который собирает наборы виджетов (радиальные gauges, полосы, status-pill и график AFR) и превращает их
  в `Screen` для рантайма. Палитра (`TouchGFXPalette`) стилизована под тёмную схему Motec.
- Экраны:
  - `main` — RPM, дроссель, давления масла/топлива, напряжение батареи, буст, график текущей/целевой смеси.
  - `temps` — охлаждайка/масло/окружающая температура и полоса ошибки AFR.
  - `race` — скорость, индекс передачи, уровень shift-light.
  - `warning` — статус-pill по критичным сенсорам.
  - `video` — лёгкий оверлей для HDMI/CarPlay/Android Auto.
- `DisplayManager` теперь передаёт `SignalBus` в рендер, чтобы виджеты TouchGFX могли считывать актуальные значения.

## Демо-режим
`demo_runtime()` генерирует несколько кадров:
- базовые значения (город/прогрев),
- «lap attack» с 8450 RPM, бустом 185 кПа, просадкой давления масла/топлива и обеднением смеси,
- HDMI и CarPlay с сохранением оверлея shift-light.

Используемые каналы сенсоров: `rpm`, `coolant_temp`, `oil_temp`, `oil_pressure`, `fuel_pressure`, `boost_kpa`, `throttle`, `lambda_current/target`, `battery_voltage`, `ambient_temp`, `gear_ratio`, `pit_limiter`.
